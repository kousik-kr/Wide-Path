import javax.swing.*;
import javax.swing.border.*;
import javax.swing.plaf.basic.BasicProgressBarUI;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import javax.swing.table.DefaultTableModel;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

/**
 * World-Class Wide-Path GUI Application
 * Features:
 * - Modern Material Design UI
 * - Real-time metrics dashboard
 * - Query history with statistics
 * - Advanced path visualization with multiple rendering modes
 * - Intelligent auto-complete and validation
 * - Export capabilities (CSV, JSON)
 * - Dark/Light theme support
 * - Performance profiling
 * - Keyboard shortcuts
 * - Responsive design
 */
public class GuiLauncher {
    // Core Components
    private final JFrame frame;
    private final ExecutorService executorService;
    private final QueryHistoryManager historyManager;
    private final MetricsCollector metricsCollector;
    private final ThemeManager themeManager;
    
    // UI Components - Input Panel
    private JTextField sourceField;
    private JTextField destinationField;
    private JSpinner departureSpinner;
    private JSpinner intervalSpinner;
    private JSpinner budgetSpinner;
    private JButton runButton;
    private JButton clearButton;
    private JButton exportButton;
    
    // UI Components - Output & Visualization
    private JTextPane outputPane;
    private AdvancedMapPanel mapPanel;
    private JProgressBar progressBar;
    private MetricsDashboard metricsDashboard;
    private QueryHistoryPanel historyPanel;
    
    // UI Components - Status & Controls
    private StatusBar statusBar;
    private JTabbedPane mainTabbedPane;
    private JMenuBar menuBar;
    
    // State Management
    private volatile boolean isQueryRunning = false;
    private List<Integer> currentPath = Collections.emptyList();
    private List<Integer> currentWideEdges = Collections.emptyList();
    private final List<QueryResult> queryHistory = new CopyOnWriteArrayList<>();
    
    // Constants
    private static final Color PRIMARY_COLOR = new Color(33, 150, 243);
    private static final Color ACCENT_COLOR = new Color(255, 87, 34);
    private static final Color SUCCESS_COLOR = new Color(76, 175, 80);
    private static final Color ERROR_COLOR = new Color(244, 67, 54);
    private static final Font TITLE_FONT = new Font("Segoe UI", Font.BOLD, 16);
    private static final Font NORMAL_FONT = new Font("Segoe UI", Font.PLAIN, 13);
    private static final Font MONO_FONT = new Font("Consolas", Font.PLAIN, 12);


    public static void main(String[] args) {
        // Set system look and feel properties
        System.setProperty("awt.useSystemAAFontSettings", "on");
        System.setProperty("swing.aatext", "true");
        
        if (GraphicsEnvironment.isHeadless()) {
            System.err.println("Headless environment detected. The Swing GUI cannot be displayed.");
            return;
        }
        
        // Use FlatLaf or Nimbus for modern look
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) {
            System.err.println("Could not set look and feel: " + e.getMessage());
        }
        
        SwingUtilities.invokeLater(() -> {
            try {
                GuiLauncher launcher = new GuiLauncher();
                launcher.start();
            } catch (Exception e) {
                e.printStackTrace();
                JOptionPane.showMessageDialog(null, 
                    "Failed to launch application: " + e.getMessage(),
                    "Startup Error", JOptionPane.ERROR_MESSAGE);
            }
        });
    }

    public GuiLauncher() {
        this.frame = new JFrame("Wide-Path Pro - Advanced Pathfinding Analysis");
        this.executorService = Executors.newFixedThreadPool(4);
        this.historyManager = new QueryHistoryManager();
        this.metricsCollector = new MetricsCollector();
        this.themeManager = new ThemeManager();
        
        // Configure frame
        frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                shutdown();
            }
        });
        
        setupKeyboardShortcuts();
    }

    private void start() {
        BidirectionalAstar.configureDefaults();
        boolean loaded = BidirectionalAstar.loadGraphFromDisk(null, null);
        if (!loaded) {
            JOptionPane.showMessageDialog(null,
                    "Failed to load graph files. Ensure the configured graph directory points to your dataset.",
                    "Graph Load Error",
                    JOptionPane.ERROR_MESSAGE);
            return;
        }
        System.out.println("[GUI] Graph loaded. Nodes=" + Graph.get_nodes().size());
        initializeUI();
        frame.setVisible(true);
    }

    private void setupKeyboardShortcuts() {
        KeyStroke runShortcut = KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.CTRL_DOWN_MASK);
        KeyStroke clearShortcut = KeyStroke.getKeyStroke(KeyEvent.VK_L, InputEvent.CTRL_DOWN_MASK);
        KeyStroke exportShortcut = KeyStroke.getKeyStroke(KeyEvent.VK_E, InputEvent.CTRL_DOWN_MASK);
        KeyStroke themeShortcut = KeyStroke.getKeyStroke(KeyEvent.VK_T, InputEvent.CTRL_DOWN_MASK);
        
        Action runAction = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (!isQueryRunning && runButton.isEnabled()) {
                    runQuery(e);
                }
            }
        };
        
        frame.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(runShortcut, "runQuery");
        frame.getRootPane().getActionMap().put("runQuery", runAction);
    }

    private void shutdown() {
        int choice = JOptionPane.showConfirmDialog(frame,
                "Are you sure you want to exit?",
                "Confirm Exit",
                JOptionPane.YES_NO_OPTION);
        
        if (choice == JOptionPane.YES_OPTION) {
            executorService.shutdown();
            try {
                if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                    executorService.shutdownNow();
                }
            } catch (InterruptedException e) {
                executorService.shutdownNow();
            }
            frame.dispose();
            System.exit(0);
        }
    }

    private void initializeUI() {
        frame.setLayout(new BorderLayout(0, 0));
        frame.setPreferredSize(new Dimension(1600, 900));
        
        // Create menu bar
        createMenuBar();
        frame.setJMenuBar(menuBar);
        
        // Create main content
        JPanel mainPanel = new JPanel(new BorderLayout(10, 10));
        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        // Create input panel (left side)
        JPanel inputPanel = createInputPanel();
        
        // Create tabbed pane for output and visualization
        mainTabbedPane = new JTabbedPane(JTabbedPane.TOP);
        mainTabbedPane.setFont(NORMAL_FONT);
        
        // Output tab
        JPanel outputPanel = createOutputPanel();
        mainTabbedPane.addTab("üìä Results", null, outputPanel, "Query results and statistics");
        
        // Visualization tab
        mapPanel = new AdvancedMapPanel();
        mainTabbedPane.addTab("üó∫Ô∏è Visualization", null, mapPanel, "Path visualization and graph explorer");
        
        // Metrics tab
        metricsDashboard = new MetricsDashboard();
        mainTabbedPane.addTab("üìà Metrics", null, metricsDashboard, "Performance metrics and analytics");
        
        // History tab
        historyPanel = new QueryHistoryPanel();
        mainTabbedPane.addTab("üïê History", null, historyPanel, "Query history and comparison");
        
        // Create split pane
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, inputPanel, mainTabbedPane);
        splitPane.setResizeWeight(0.25);
        splitPane.setDividerSize(8);
        
        mainPanel.add(splitPane, BorderLayout.CENTER);
        
        // Create status bar
        statusBar = new StatusBar();
        mainPanel.add(statusBar, BorderLayout.SOUTH);
        
        frame.add(mainPanel);
        frame.pack();
        frame.setLocationRelativeTo(null);
        
        statusBar.setMessage("Ready. Graph loaded with " + Graph.get_nodes().size() + " nodes.", StatusBar.MessageType.INFO);
    }

        JPanel form = new JPanel();
        form.setLayout(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.insets = new Insets(4, 4, 4, 4);
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;

        sourceField = new JTextField("0", 10);
        destinationField = new JTextField("0", 10);
        departureField = new JTextField("450", 10);
        intervalField = new JTextField("360", 10);
        budgetField = new JTextField("45", 10);

        int row = 0;
        row = addRow(form, c, row, "Source node ID:", sourceField);
        row = addRow(form, c, row, "Destination node ID:", destinationField);
        row = addRow(form, c, row, "Departure time (minutes from 00:00):", departureField);
        row = addRow(form, c, row, "Interval duration (minutes):", intervalField);
        row = addRow(form, c, row, "Budget (minutes):", budgetField);

        JButton runButton = new JButton("Run Query");
        runButton.addActionListener(this::runQuery);
        c.gridx = 0;
        c.gridy = row;
        c.gridwidth = 2;
        form.add(runButton, c);

        outputArea = new JTextArea(16, 48);
        outputArea.setEditable(false);
        outputArea.setLineWrap(true);
        outputArea.setWrapStyleWord(true);
        JScrollPane outputScroll = new JScrollPane(outputArea);
        outputScroll.setBorder(BorderFactory.createTitledBorder("Output"));

        statusLabel = new JLabel("Graph loaded. Ready.");

        mapPanel = new MapPanel();

        JSplitPane topSplit = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, form, outputScroll);
        topSplit.setResizeWeight(0.45);
        topSplit.setBorder(BorderFactory.createEmptyBorder());

        frame.add(topSplit, BorderLayout.NORTH);
        frame.add(mapPanel, BorderLayout.CENTER);
        frame.add(statusLabel, BorderLayout.SOUTH);
        frame.pack();
        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
    }

    private int addRow(JPanel panel, GridBagConstraints c, int row, String label, JComponent field) {
        c.gridx = 0;
        c.gridy = row;
        c.gridwidth = 1;
        panel.add(new JLabel(label), c);
        c.gridx = 1;
        panel.add(field, c);
        return row + 1;
    }

    private void runQuery(ActionEvent event) {
        statusLabel.setText("Running query...");
        outputArea.setText("");
        int source, dest;
        double departure, interval, budget;
        try {
            source = Integer.parseInt(sourceField.getText().trim());
            dest = Integer.parseInt(destinationField.getText().trim());
            departure = Double.parseDouble(departureField.getText().trim());
            interval = Double.parseDouble(intervalField.getText().trim());
            budget = Double.parseDouble(budgetField.getText().trim());
        } catch (NumberFormatException nfe) {
            statusLabel.setText("Invalid input: " + nfe.getMessage());
            return;
        }

        // Visualize input parameters before processing
        StringBuilder inputDisplay = new StringBuilder();
        inputDisplay.append("=== Query Input Parameters ===\n");
        inputDisplay.append("Source Node ID: ").append(source).append("\n");
        inputDisplay.append("Destination Node ID: ").append(dest).append("\n");
        inputDisplay.append("Departure Time: ").append(departure).append(" minutes from 00:00\n");
        inputDisplay.append("Interval Duration: ").append(interval).append(" minutes\n");
        inputDisplay.append("Budget: ").append(budget).append(" minutes\n");
        inputDisplay.append("===============================\n\n");
        inputDisplay.append("Processing query, please wait...\n");
        outputArea.setText(inputDisplay.toString());

        SwingWorker<Void, Void> worker = new SwingWorker<>() {
            Result result;
            long elapsedMs;

            @Override
            protected Void doInBackground() {
                long start = System.currentTimeMillis();
                try {
                    BidirectionalAstar.setIntervalDuration(interval);
                    System.out.println("[GUI] Running query " + source + " -> " + dest + " dep=" + departure + " interval=" + interval + " budget=" + budget);
                    result = BidirectionalAstar.runSingleQuery(source, dest, departure, interval, budget);
                } catch (InterruptedException | ExecutionException e) {
                    result = null;
                    outputArea.setText("Error: " + e.getMessage());
                    System.err.println("[GUI] Query error: " + e.getMessage());
                } finally {
                    elapsedMs = System.currentTimeMillis() - start;
                    System.out.println("[GUI] Query finished in " + elapsedMs + " ms");
                }
                return null;
            }

            @Override
            protected void done() {
                if (result == null) {
                    currentPath = Collections.emptyList();
                    currentWideEdges = Collections.emptyList();
                    mapPanel.setPath(currentPath, currentWideEdges);
                    statusLabel.setText("Query failed.");
                    return;
                }
                StringBuilder sb = new StringBuilder();
                sb.append("=== Query Input Parameters ===\n");
                sb.append("Source Node ID: ").append(source).append("\n");
                sb.append("Destination Node ID: ").append(dest).append("\n");
                sb.append("Departure Time: ").append(departure).append(" minutes from 00:00\n");
                sb.append("Interval Duration: ").append(interval).append(" minutes\n");
                sb.append("Budget: ").append(budget).append(" minutes\n");
                sb.append("===============================\n\n");
                sb.append("=== Query Results ===\n");
                sb.append("Source -> Destination: ").append(source).append(" -> ").append(dest).append("\n");
                sb.append("Departure (input / result): ").append(departure).append(" / ").append(result.get_departureTime()).append("\n");
                sb.append("Score: ").append(result.get_score()).append("\n");
                sb.append("Travel time (approx): ").append(String.format("%.2f", result.get_travel_time())).append(" mins\n");
                sb.append("Right turns: ").append(result.get_right_turns()).append("\n");
                sb.append("Sharp turns: ").append(result.get_sharp_turns()).append("\n");

                List<Integer> path = result.get_pathNodes();
                List<Integer> wideEdges = result.get_wideEdgeIndices();
                currentPath = path != null ? path : Collections.emptyList();
                currentWideEdges = wideEdges != null ? wideEdges : Collections.emptyList();
                mapPanel.setPath(currentPath, currentWideEdges);

                if (path != null && path.size() > 1) {
                    sb.append("Path edges (wide edges marked *):\n");
                    for (int i = 0; i < path.size() - 1; i++) {
                        int u = path.get(i);
                        int v = path.get(i + 1);
                        boolean isWide = wideEdges != null && wideEdges.contains(i);
                        sb.append(u).append(" -> ").append(v);
                        if (isWide) sb.append("  *wide");
                        sb.append("\n");
                    }
                } else {
                    sb.append("No path computed.\n");
                }

                sb.append("Elapsed: ").append(elapsedMs / 1000.0).append(" seconds\n");
                outputArea.setText(sb.toString());
                statusLabel.setText("Done.");
            }
        };
        worker.execute();
    }

    private static class MapPanel extends JPanel {
        private List<Integer> path = Collections.emptyList();
        private List<Integer> wideEdgeIndices = Collections.emptyList();
        private List<Integer> allNodeIds = new ArrayList<>();
        private int currentPage = 0;
        private int nodesPerPage = 50;
        private JLabel pageInfoLabel;
        private JSlider pageSlider;
        private JButton prevButton;
        private JButton nextButton;
        private JSpinner nodesPerPageSpinner;
        private GraphCanvas graphCanvas;
        private JCheckBox showPathOnlyCheckbox;
        private javax.swing.Timer animationTimer;
        private int animationStep = 0;
        private boolean isAnimating = false;
        private JButton animateButton;
        private JComboBox<String> visualStyleCombo;

        MapPanel() {
            setLayout(new BorderLayout(5, 5));
            setPreferredSize(new Dimension(520, 640));
            setBorder(BorderFactory.createTitledBorder("Map (nodes & directed edges)"));

            // Create the graph drawing canvas
            graphCanvas = new GraphCanvas();

            // Create navigation controls panel
            JPanel controlsPanel = new JPanel(new BorderLayout(5, 5));
            controlsPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

            // Top row: Page info and nodes per page
            JPanel topRow = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 2));
            pageInfoLabel = new JLabel("Page 1 of 1");
            topRow.add(pageInfoLabel);
            topRow.add(new JLabel("  |  Nodes per page:"));
            nodesPerPageSpinner = new JSpinner(new SpinnerNumberModel(50, 10, 500, 10));
            nodesPerPageSpinner.setPreferredSize(new Dimension(70, 25));
            nodesPerPageSpinner.addChangeListener(e -> {
                nodesPerPage = (Integer) nodesPerPageSpinner.getValue();
                currentPage = 0;
                updateControls();
                graphCanvas.repaint();
            });
            topRow.add(nodesPerPageSpinner);
            
            showPathOnlyCheckbox = new JCheckBox("Show Path Only");
            showPathOnlyCheckbox.addActionListener(e -> {
                currentPage = 0;
                updateControls();
                graphCanvas.repaint();
            });
            topRow.add(showPathOnlyCheckbox);

            // Visualization style selector
            topRow.add(new JLabel("  |  Style:"));
            visualStyleCombo = new JComboBox<>(new String[]{
                "Classic", "Neon Glow", "Gradient Flow", "3D Effect", "Pulse Animation"
            });
            visualStyleCombo.addActionListener(e -> graphCanvas.repaint());
            topRow.add(visualStyleCombo);

            // Middle row: Slider
            JPanel sliderRow = new JPanel(new BorderLayout(5, 0));
            sliderRow.add(new JLabel("Navigate: "), BorderLayout.WEST);
            pageSlider = new JSlider(0, 0, 0);
            pageSlider.setMajorTickSpacing(1);
            pageSlider.setPaintTicks(true);
            pageSlider.addChangeListener(e -> {
                if (!pageSlider.getValueIsAdjusting()) {
                    currentPage = pageSlider.getValue();
                    updatePageInfo();
                    graphCanvas.repaint();
                }
            });
            sliderRow.add(pageSlider, BorderLayout.CENTER);

            // Bottom row: Prev/Next buttons
            JPanel buttonRow = new JPanel(new FlowLayout(FlowLayout.CENTER, 15, 2));
            prevButton = new JButton("<< Previous");
            prevButton.addActionListener(e -> {
                if (currentPage > 0) {
                    currentPage--;
                    updateControls();
                    graphCanvas.repaint();
                }
            });
            nextButton = new JButton("Next >>");
            nextButton.addActionListener(e -> {
                int totalPages = getTotalPages();
                if (currentPage < totalPages - 1) {
                    currentPage++;
                    updateControls();
                    graphCanvas.repaint();
                }
            });
            JButton showAllButton = new JButton("Show All");
            showAllButton.addActionListener(e -> {
                nodesPerPage = Math.max(getDisplayNodeIds().size(), 10);
                nodesPerPageSpinner.setValue(nodesPerPage);
                currentPage = 0;
                updateControls();
                graphCanvas.repaint();
            });
            
            // Animate path button
            animateButton = new JButton("‚ñ∂ Animate Path");
            animateButton.setBackground(new Color(0x4CAF50));
            animateButton.setForeground(Color.WHITE);
            animateButton.setFocusPainted(false);
            animateButton.addActionListener(e -> toggleAnimation());
            
            buttonRow.add(prevButton);
            buttonRow.add(showAllButton);
            buttonRow.add(animateButton);
            buttonRow.add(nextButton);

            controlsPanel.add(topRow, BorderLayout.NORTH);
            controlsPanel.add(sliderRow, BorderLayout.CENTER);
            controlsPanel.add(buttonRow, BorderLayout.SOUTH);

            add(graphCanvas, BorderLayout.CENTER);
            add(controlsPanel, BorderLayout.SOUTH);

            // Initialize animation timer
            animationTimer = new javax.swing.Timer(100, e -> {
                animationStep++;
                if (path != null && animationStep > path.size() * 10) {
                    animationStep = 0;
                }
                graphCanvas.repaint();
            });

            refreshNodeList();
        }

        private void toggleAnimation() {
            if (path == null || path.isEmpty()) {
                JOptionPane.showMessageDialog(this, "No path to animate. Run a query first.", 
                    "No Path", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            isAnimating = !isAnimating;
            if (isAnimating) {
                animationStep = 0;
                animateButton.setText("‚è∏ Pause");
                animateButton.setBackground(new Color(0xFF9800));
                animationTimer.start();
            } else {
                animateButton.setText("‚ñ∂ Animate Path");
                animateButton.setBackground(new Color(0x4CAF50));
                animationTimer.stop();
                graphCanvas.repaint();
            }
        }

        private void refreshNodeList() {
            Map<Integer, Node> nodes = Graph.get_nodes();
            allNodeIds.clear();
            if (nodes != null) {
                allNodeIds.addAll(nodes.keySet());
                Collections.sort(allNodeIds);
            }
            updateControls();
        }

        private List<Integer> getDisplayNodeIds() {
            if (showPathOnlyCheckbox.isSelected() && path != null && !path.isEmpty()) {
                return path;
            }
            return allNodeIds;
        }

        private int getTotalPages() {
            List<Integer> displayIds = getDisplayNodeIds();
            if (displayIds.isEmpty()) return 1;
            return (int) Math.ceil((double) displayIds.size() / nodesPerPage);
        }

        private void updateControls() {
            int totalPages = getTotalPages();
            if (currentPage >= totalPages) {
                currentPage = Math.max(0, totalPages - 1);
            }
            pageSlider.setMaximum(Math.max(0, totalPages - 1));
            pageSlider.setValue(currentPage);
            prevButton.setEnabled(currentPage > 0);
            nextButton.setEnabled(currentPage < totalPages - 1);
            updatePageInfo();
        }

        private void updatePageInfo() {
            List<Integer> displayIds = getDisplayNodeIds();
            int totalNodes = displayIds.size();
            int totalPages = getTotalPages();
            int startNode = currentPage * nodesPerPage + 1;
            int endNode = Math.min((currentPage + 1) * nodesPerPage, totalNodes);
            String mode = showPathOnlyCheckbox.isSelected() ? " (Path)" : "";
            pageInfoLabel.setText(String.format("Showing nodes %d-%d of %d%s | Page %d of %d",
                    startNode, endNode, totalNodes, mode, currentPage + 1, totalPages));
        }

        void setPath(List<Integer> path, List<Integer> wideEdgeIndices) {
            this.path = path != null ? new ArrayList<>(path) : Collections.emptyList();
            this.wideEdgeIndices = wideEdgeIndices != null ? new ArrayList<>(wideEdgeIndices) : Collections.emptyList();
            if (isAnimating) {
                toggleAnimation(); // Stop animation if running
            }
            animationStep = 0;
            refreshNodeList();
            graphCanvas.repaint();
        }

        private class GraphCanvas extends JPanel {
            GraphCanvas() {
                setBackground(Color.WHITE);
            }

            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                Map<Integer, Node> nodes = Graph.get_nodes();
                if (nodes == null || nodes.isEmpty()) {
                    drawCenteredText(g, "No nodes loaded");
                    return;
                }

                List<Integer> displayIds = getDisplayNodeIds();
                if (displayIds.isEmpty()) {
                    drawCenteredText(g, "No nodes to display");
                    return;
                }

                // Get current page nodes
                int startIdx = currentPage * nodesPerPage;
                int endIdx = Math.min(startIdx + nodesPerPage, displayIds.size());
                List<Integer> currentPageNodeIds = displayIds.subList(startIdx, endIdx);

                // Calculate bounds for current page nodes only
                double minLat = Double.POSITIVE_INFINITY, maxLat = Double.NEGATIVE_INFINITY;
                double minLon = Double.POSITIVE_INFINITY, maxLon = Double.NEGATIVE_INFINITY;
                for (Integer nodeId : currentPageNodeIds) {
                    Node n = nodes.get(nodeId);
                    if (n == null) continue;
                    double lat = n.get_latitude();
                    double lon = n.get_longitude();
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lon < minLon) minLon = lon;
                    if (lon > maxLon) maxLon = lon;
                }
                if (!Double.isFinite(minLat) || !Double.isFinite(minLon)) {
                    drawCenteredText(g, "Invalid coordinates");
                    return;
                }

                Graphics2D g2 = (Graphics2D) g;
                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                int w = getWidth();
                int h = getHeight();
                int padding = 40;
                double xRange = Math.max(maxLon - minLon, 1e-6);
                double yRange = Math.max(maxLat - minLat, 1e-6);

                // Create a set for quick lookup
                java.util.Set<Integer> currentPageSet = new java.util.HashSet<>(currentPageNodeIds);

                String style = (String) visualStyleCombo.getSelectedItem();

                // Draw edges for current page nodes
                for (Integer nodeId : currentPageNodeIds) {
                    Node from = nodes.get(nodeId);
                    if (from == null) continue;
                    for (Edge edge : from.get_outgoing_edges().values()) {
                        Node to = nodes.get(edge.get_destination());
                        if (to == null) continue;
                        // Only draw edge if destination is also in current page
                        if (!currentPageSet.contains(edge.get_destination())) continue;
                        Point p1 = project(from, w, h, padding, minLon, minLat, xRange, yRange, maxLat);
                        Point p2 = project(to, w, h, padding, minLon, minLat, xRange, yRange, maxLat);
                        
                        if ("3D Effect".equals(style)) {
                            // Draw shadow for 3D effect
                            g2.setColor(new Color(0, 0, 0, 30));
                            g2.setStroke(new BasicStroke(2.0f));
                            drawArrow(g2, p1.x + 2, p1.y + 2, p2.x + 2, p2.y + 2);
                        }
                        
                        g2.setColor(new Color(0x2D7DD2));
                        g2.setStroke(new BasicStroke(1.4f));
                        drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
                    }
                }

                // Draw regular nodes
                for (Integer nodeId : currentPageNodeIds) {
                    Node n = nodes.get(nodeId);
                    if (n == null) continue;
                    Point p = project(n, w, h, padding, minLon, minLat, xRange, yRange, maxLat);
                    
                    // Highlight if part of path
                    boolean isPathNode = path != null && path.contains(nodeId);
                    
                    if ("3D Effect".equals(style)) {
                        // Shadow
                        g2.setColor(new Color(0, 0, 0, 50));
                        g2.fillOval(p.x - 2, p.y - 2, isPathNode ? 12 : 8, isPathNode ? 12 : 8);
                    }
                    
                    if (isPathNode) {
                        g2.setColor(new Color(0x0A8754));
                        g2.fillOval(p.x - 5, p.y - 5, 10, 10);
                    } else {
                        g2.setColor(Color.DARK_GRAY);
                        g2.fillOval(p.x - 3, p.y - 3, 6, 6);
                    }
                    
                    // Draw node ID label for path nodes or if few nodes
                    if (isPathNode || currentPageNodeIds.size() <= 30) {
                        g2.setColor(Color.BLACK);
                        g2.setFont(new Font("SansSerif", Font.PLAIN, 9));
                        g2.drawString(String.valueOf(nodeId), p.x + 5, p.y - 3);
                    }
                }

                // Draw path edges with creative visualization
                if (path != null && path.size() > 1) {
                    drawCreativePath(g2, nodes, currentPageSet, w, h, padding, 
                                   minLon, minLat, xRange, yRange, maxLat, style);
                }

                // Draw legend
                drawLegend(g2, w, style);
            }

            private void drawCreativePath(Graphics2D g2, Map<Integer, Node> nodes, 
                                         java.util.Set<Integer> currentPageSet,
                                         int w, int h, int padding,
                                         double minLon, double minLat, double xRange, 
                                         double yRange, double maxLat, String style) {
                String selectedStyle = style != null ? style : "Classic";
                
                for (int i = 0; i < path.size() - 1; i++) {
                    int u = path.get(i);
                    int v = path.get(i + 1);
                    // Only draw if both nodes are in current page
                    if (!currentPageSet.contains(u) || !currentPageSet.contains(v)) continue;
                    Node from = nodes.get(u);
                    Node to = nodes.get(v);
                    if (from == null || to == null) continue;
                    Point p1 = project(from, w, h, padding, minLon, minLat, xRange, yRange, maxLat);
                    Point p2 = project(to, w, h, padding, minLon, minLat, xRange, yRange, maxLat);
                    boolean wide = wideEdgeIndices != null && wideEdgeIndices.contains(i);
                    
                    // Check if this segment should be animated
                    boolean isAnimated = isAnimating && (animationStep / 10) >= i;
                    float alpha = 1.0f;
                    if (isAnimating && (animationStep / 10) == i) {
                        alpha = (animationStep % 10) / 10.0f;
                    }
                    
                    switch (selectedStyle) {
                        case "Neon Glow":
                            drawNeonGlowPath(g2, p1, p2, wide, isAnimated, alpha);
                            break;
                        case "Gradient Flow":
                            drawGradientPath(g2, p1, p2, wide, i, path.size(), isAnimated, alpha);
                            break;
                        case "3D Effect":
                            draw3DPath(g2, p1, p2, wide, isAnimated, alpha);
                            break;
                        case "Pulse Animation":
                            drawPulsePath(g2, p1, p2, wide, isAnimated, alpha);
                            break;
                        default: // Classic
                            drawClassicPath(g2, p1, p2, wide, isAnimated, alpha);
                            break;
                    }
                    
                    // Draw animated marker on current edge during animation
                    if (isAnimating && (animationStep / 10) == i) {
                        float progress = (animationStep % 10) / 10.0f;
                        int markerX = (int) (p1.x + (p2.x - p1.x) * progress);
                        int markerY = (int) (p1.y + (p2.y - p1.y) * progress);
                        g2.setColor(new Color(255, 215, 0, 230)); // Gold
                        g2.fillOval(markerX - 6, markerY - 6, 12, 12);
                        g2.setColor(new Color(255, 255, 255));
                        g2.setStroke(new BasicStroke(2));
                        g2.drawOval(markerX - 6, markerY - 6, 12, 12);
                    }
                }
                
                // Draw start and end markers
                if (!path.isEmpty() && currentPageSet.contains(path.get(0))) {
                    Node start = nodes.get(path.get(0));
                    if (start != null) {
                        Point p = project(start, w, h, padding, minLon, minLat, xRange, yRange, maxLat);
                        drawStartMarker(g2, p);
                    }
                }
                if (!path.isEmpty() && currentPageSet.contains(path.get(path.size() - 1))) {
                    Node end = nodes.get(path.get(path.size() - 1));
                    if (end != null) {
                        Point p = project(end, w, h, padding, minLon, minLat, xRange, yRange, maxLat);
                        drawEndMarker(g2, p);
                    }
                }
            }

            private void drawClassicPath(Graphics2D g2, Point p1, Point p2, 
                                        boolean wide, boolean isAnimated, float alpha) {
                Color baseColor = wide ? new Color(0xE4572E) : new Color(0x0A8754);
                g2.setColor(new Color(baseColor.getRed(), baseColor.getGreen(), 
                                     baseColor.getBlue(), (int)(255 * alpha)));
                g2.setStroke(new BasicStroke(wide ? 4.0f : 2.5f));
                drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
            }

            private void drawNeonGlowPath(Graphics2D g2, Point p1, Point p2, 
                                         boolean wide, boolean isAnimated, float alpha) {
                Color glowColor = wide ? new Color(231, 76, 60) : new Color(46, 204, 113);
                
                // Outer glow
                for (int i = 5; i > 0; i--) {
                    g2.setColor(new Color(glowColor.getRed(), glowColor.getGreen(), 
                                         glowColor.getBlue(), (int)(30 * alpha)));
                    g2.setStroke(new BasicStroke((wide ? 4.0f : 2.5f) + i * 2));
                    drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
                }
                
                // Core line
                g2.setColor(new Color(glowColor.getRed(), glowColor.getGreen(), 
                                     glowColor.getBlue(), (int)(255 * alpha)));
                g2.setStroke(new BasicStroke(wide ? 4.0f : 2.5f));
                drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
            }

            private void drawGradientPath(Graphics2D g2, Point p1, Point p2, boolean wide,
                                         int index, int totalEdges, boolean isAnimated, float alpha) {
                float ratio = (float) index / totalEdges;
                Color startColor = new Color(46, 204, 113); // Green
                Color endColor = wide ? new Color(231, 76, 60) : new Color(52, 152, 219); // Red or Blue
                
                int r = (int) (startColor.getRed() + ratio * (endColor.getRed() - startColor.getRed()));
                int g = (int) (startColor.getGreen() + ratio * (endColor.getGreen() - startColor.getGreen()));
                int b = (int) (startColor.getBlue() + ratio * (endColor.getBlue() - startColor.getBlue()));
                
                GradientPaint gradient = new GradientPaint(p1.x, p1.y, 
                    new Color(r, g, b, (int)(255 * alpha)),
                    p2.x, p2.y, 
                    new Color(endColor.getRed(), endColor.getGreen(), endColor.getBlue(), (int)(255 * alpha)));
                g2.setPaint(gradient);
                g2.setStroke(new BasicStroke(wide ? 5.0f : 3.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
                drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
            }

            private void draw3DPath(Graphics2D g2, Point p1, Point p2, 
                                   boolean wide, boolean isAnimated, float alpha) {
                // Shadow layer
                g2.setColor(new Color(0, 0, 0, (int)(80 * alpha)));
                g2.setStroke(new BasicStroke(wide ? 5.0f : 3.5f));
                drawArrow(g2, p1.x + 3, p1.y + 3, p2.x + 3, p2.y + 3);
                
                // Middle layer
                Color baseColor = wide ? new Color(0xE4572E) : new Color(0x0A8754);
                g2.setColor(new Color(baseColor.getRed(), baseColor.getGreen(), 
                                     baseColor.getBlue(), (int)(200 * alpha)));
                g2.setStroke(new BasicStroke(wide ? 4.5f : 3.0f));
                drawArrow(g2, p1.x + 1, p1.y + 1, p2.x + 1, p2.y + 1);
                
                // Top highlight layer
                Color highlight = wide ? new Color(255, 107, 76) : new Color(40, 180, 99);
                g2.setColor(new Color(highlight.getRed(), highlight.getGreen(), 
                                     highlight.getBlue(), (int)(255 * alpha)));
                g2.setStroke(new BasicStroke(wide ? 4.0f : 2.5f));
                drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
            }

            private void drawPulsePath(Graphics2D g2, Point p1, Point p2, 
                                      boolean wide, boolean isAnimated, float alpha) {
                float pulse = isAnimated ? (float)(0.5 + 0.5 * Math.sin(animationStep * 0.2)) : 1.0f;
                Color baseColor = wide ? new Color(0xE4572E) : new Color(0x0A8754);
                
                // Pulsing glow
                int glowSize = (int)(pulse * 8);
                for (int i = glowSize; i > 0; i--) {
                    int alphaVal = (int)(50 * alpha * (1.0f - (float)i / glowSize));
                    g2.setColor(new Color(baseColor.getRed(), baseColor.getGreen(), 
                                         baseColor.getBlue(), alphaVal));
                    g2.setStroke(new BasicStroke((wide ? 4.0f : 2.5f) + i));
                    drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
                }
                
                // Core with pulsing width
                g2.setColor(new Color(baseColor.getRed(), baseColor.getGreen(), 
                                     baseColor.getBlue(), (int)(255 * alpha)));
                g2.setStroke(new BasicStroke((wide ? 4.0f : 2.5f) * pulse));
                drawArrow(g2, p1.x, p1.y, p2.x, p2.y);
            }

            private void drawStartMarker(Graphics2D g2, Point p) {
                // Green circle with 'S'
                g2.setColor(new Color(46, 204, 113));
                g2.fillOval(p.x - 12, p.y - 12, 24, 24);
                g2.setColor(Color.WHITE);
                g2.setStroke(new BasicStroke(2));
                g2.drawOval(p.x - 12, p.y - 12, 24, 24);
                g2.setFont(new Font("SansSerif", Font.BOLD, 14));
                FontMetrics fm = g2.getFontMetrics();
                g2.drawString("S", p.x - fm.stringWidth("S") / 2, p.y + fm.getAscent() / 2 - 1);
            }

            private void drawEndMarker(Graphics2D g2, Point p) {
                // Red circle with 'E'
                g2.setColor(new Color(231, 76, 60));
                g2.fillOval(p.x - 12, p.y - 12, 24, 24);
                g2.setColor(Color.WHITE);
                g2.setStroke(new BasicStroke(2));
                g2.drawOval(p.x - 12, p.y - 12, 24, 24);
                g2.setFont(new Font("SansSerif", Font.BOLD, 14));
                FontMetrics fm = g2.getFontMetrics();
                g2.drawString("E", p.x - fm.stringWidth("E") / 2, p.y + fm.getAscent() / 2 - 1);
            }

            private void drawLegend(Graphics2D g2, int w, String style) {
                int x = w - 150;
                int y = 15;
                g2.setFont(new Font("SansSerif", Font.BOLD, 11));
                g2.setColor(Color.BLACK);
                g2.drawString("Legend:", x, y);
                
                y += 18;
                g2.setFont(new Font("SansSerif", Font.PLAIN, 10));
                
                // Graph edge
                g2.setColor(new Color(0x2D7DD2));
                g2.setStroke(new BasicStroke(1.4f));
                g2.drawLine(x, y, x + 20, y);
                g2.setColor(Color.BLACK);
                g2.drawString("Graph edge", x + 25, y + 4);
                
                // Path edge (style-dependent)
                y += 15;
                if ("Neon Glow".equals(style)) {
                    for (int i = 3; i > 0; i--) {
                        g2.setColor(new Color(46, 204, 113, 20));
                        g2.setStroke(new BasicStroke(2.5f + i * 2));
                        g2.drawLine(x, y, x + 20, y);
                    }
                    g2.setColor(new Color(46, 204, 113));
                    g2.setStroke(new BasicStroke(2.5f));
                    g2.drawLine(x, y, x + 20, y);
                } else if ("Gradient Flow".equals(style)) {
                    GradientPaint gp = new GradientPaint(x, y, new Color(46, 204, 113),
                                                         x + 20, y, new Color(52, 152, 219));
                    g2.setPaint(gp);
                    g2.setStroke(new BasicStroke(3.0f));
                    g2.drawLine(x, y, x + 20, y);
                } else {
                    g2.setColor(new Color(0x0A8754));
                    g2.setStroke(new BasicStroke(2.5f));
                    g2.drawLine(x, y, x + 20, y);
                }
                g2.setColor(Color.BLACK);
                g2.drawString("Path edge", x + 25, y + 4);
                
                // Wide edge
                y += 15;
                g2.setColor(new Color(0xE4572E));
                g2.setStroke(new BasicStroke(4.0f));
                g2.drawLine(x, y, x + 20, y);
                g2.setColor(Color.BLACK);
                g2.drawString("Wide edge", x + 25, y + 4);
                
                // Start/End markers
                y += 18;
                g2.setColor(new Color(46, 204, 113));
                g2.fillOval(x + 5, y - 6, 12, 12);
                g2.setColor(Color.WHITE);
                g2.setFont(new Font("SansSerif", Font.BOLD, 9));
                FontMetrics fm = g2.getFontMetrics();
                g2.drawString("S", x + 11 - fm.stringWidth("S") / 2, y + 2);
                g2.setColor(Color.BLACK);
                g2.setFont(new Font("SansSerif", Font.PLAIN, 10));
                g2.drawString("Start", x + 25, y + 4);
                
                y += 15;
                g2.setColor(new Color(231, 76, 60));
                g2.fillOval(x + 5, y - 6, 12, 12);
                g2.setColor(Color.WHITE);
                g2.setFont(new Font("SansSerif", Font.BOLD, 9));
                g2.drawString("E", x + 11 - fm.stringWidth("E") / 2, y + 2);
                g2.setColor(Color.BLACK);
                g2.setFont(new Font("SansSerif", Font.PLAIN, 10));
                g2.drawString("End", x + 25, y + 4);
            }

            private void drawCenteredText(Graphics g, String text) {
                FontMetrics fm = g.getFontMetrics();
                int x = (getWidth() - fm.stringWidth(text)) / 2;
                int y = (getHeight() + fm.getAscent()) / 2;
                g.drawString(text, x, y);
            }

            private Point project(Node n, int w, int h, int padding,
                                  double minLon, double minLat, double xRange, double yRange, double maxLat) {
                double xNorm = (n.get_longitude() - minLon) / xRange;
                double yNorm = (maxLat - n.get_latitude()) / yRange;
                int x = (int) (padding + xNorm * (w - 2 * padding));
                int y = (int) (padding + yNorm * (h - 2 * padding));
                return new Point(x, y);
            }

            private void drawArrow(Graphics2D g2, int x1, int y1, int x2, int y2) {
                g2.drawLine(x1, y1, x2, y2);
                double dx = x2 - x1;
                double dy = y2 - y1;
                double angle = Math.atan2(dy, dx);
                int len = 10;
                int wing = 4;
                int xArrow1 = (int) (x2 - len * Math.cos(angle) + wing * Math.sin(angle));
                int yArrow1 = (int) (y2 - len * Math.sin(angle) - wing * Math.cos(angle));
                int xArrow2 = (int) (x2 - len * Math.cos(angle) - wing * Math.sin(angle));
                int yArrow2 = (int) (y2 - len * Math.sin(angle) + wing * Math.cos(angle));
                Polygon head = new Polygon();
                head.addPoint(x2, y2);
                head.addPoint(xArrow1, yArrow1);
                head.addPoint(xArrow2, yArrow2);
                g2.fillPolygon(head);
            }
        }
    }
}
